name: All Tests
# on:
#   push:
#     branches:
#       - master 
on: [push]

jobs:
  tests:
    name: All Tests on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
        matrix:
            os: ["windows-latest", "macos-latest", "ubuntu-latest"]
    steps:
      - uses: actions/checkout@v4
      - uses: conda-incubator/setup-miniconda@v3
        with:
          miniconda-version: "latest"
          auto-activate-base: true
          conda-remove-defaults: true
      # -----------------------------------------------------------
      # Add 12GB swap (OS-specific)
      # -----------------------------------------------------------
      - name: Add 12GB swap (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo fallocate -l 12G /swapfile
          sudo chmod 600 /swapfile
          sudo mkswap /swapfile
          sudo swapon /swapfile
          free -h

      - name: Add 12GB swap (macOS)
        if: runner.os == 'macOS'
        run: |
          # Create and mount a temporary swapfile
          sudo mkfile 12g /private/var/vm/tempswapfile
          sudo chmod 600 /private/var/vm/tempswapfile

      - name: Add 8GB swap space (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $desiredMB = 8192
          $auto = 'D:\pagefile_auto.sys'

          # Disable automatic pagefile management
          try {
            $cs = Get-CimInstance -ClassName Win32_ComputerSystem
            if ($cs.AutomaticManagedPagefile) {
              Write-Host "Disabling AutomaticManagedPagefile"
              Set-CimInstance -InputObject $cs -Property @{AutomaticManagedPagefile=$false}
            }
          } catch {
            Write-Warning "Could not disable AutomaticManagedPagefile: $_"
          }

          # Create a new pagefile (creating new file more likely to work without reboot)
          try {
            $exists = Get-CimInstance -ClassName Win32_PageFileSetting | Where-Object { $_.Name -eq $auto }
          } catch { $exists = $null }

          if (-not $exists) {
            Write-Host "Creating new pagefile: $auto (${desiredMB} MB)"
            try {
              $null = Set-WmiInstance -Class Win32_PageFileSetting -Arguments @{Name=$auto; InitialSize=[UInt32]$desiredMB; MaximumSize=[UInt32]$desiredMB}
              Write-Host "Pagefile created. May take effect immediately or require reboot."
            } catch {
              Write-Warning "Failed to create pagefile: $_"
            }
          } else {
            Write-Host "Pagefile $auto already exists."
          }

      # -----------------------------------------------------------
      # Free disk + conda cache early (OS-specific)
      # -----------------------------------------------------------
      - name: Free space (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get clean
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc
          conda clean --all --yes
          pip cache purge || true
          df -h

      - name: Free space (macOS)
        if: runner.os == 'macOS'
        run: |
          conda clean --all --yes
          pip cache purge || true
          df -h

      - name: Free space (Windows)
        if: runner.os == 'Windows'
        run: |
          conda clean --all --yes || true
          pip cache purge || true
          Get-Volume | Select-Object DriveLetter, Size, SizeRemaining | Format-Table

      # -----------------------------------------------------------
      # Show resources (OS-specific)
      # -----------------------------------------------------------
      - name: Show runner resources
        if: runner.os != 'Windows'
        run: |
          echo "CPUs: $(nproc || sysctl -n hw.ncpu)"
          free -h || vm_stat
          df -h

      - name: Show runner resources
        if: runner.os == 'Windows'
        run: |
          # Check current pagefile settings
          Get-WmiObject Win32_PageFileUsage | Select-Object Name, AllocatedBaseSize
          # Display system memory info
          Get-ComputerInfo -Property CsTotalPhysicalMemory

      # -----------------------------------------------------------
      # Install Python dependencies
      # -----------------------------------------------------------
          
      - run: pip install -e .[test]

      # -----------------------------------------------------------
      # Install minimal LaTeX (OS-specific)
      # -----------------------------------------------------------
      - name: Install minimal LaTeX (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt update
          sudo apt install -y texlive-latex-base texlive-latex-extra texlive-latex-recommended latexmk dvipng cm-super

      - name: Install minimal LaTeX (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install --cask basictex
          eval "$(/usr/libexec/path_helper)"
          sudo tlmgr update --self
          sudo tlmgr install latexmk dvipng collection-fontsrecommended type1cm
          
      - name: Install minimal LaTeX (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install miktex -y
          choco install strawberryperl -y
          # Put MiKTeX on PATH for all subsequent steps
          echo "C:\Program Files\MiKTeX\miktex\bin\x64" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          # Refresh PATH in current session
          $env:PATH = "C:\Program Files\MiKTeX\miktex\bin\x64;$env:PATH"
          # Enable auto-install of missing packages (MiKTeX "just enough TeX" approach)
          initexmf --admin --set-config-value [MPM]AutoInstall=1
          # Refresh package database + upgrade base
          mpm --admin --update-db
          mpm --admin --upgrade
          # Install a few common "baseline" packages explicitly (names are MiKTeX packages)
          mpm --admin --install=latexmk
          mpm --admin --install=dvipng
          latex --version
          latexmk -v
          dvipng --version

      # -----------------------------------------------------------
      # Run doectests (OS-specific)
      # -----------------------------------------------------------      
      - run: pip freeze
      - run: make doctests_minimal
      - run: pip install -e .[test_torch] 
      - run: make doctests_torch 
      - run: pip install -e .[test_gpytorch]
      - run: make doctests_gpytorch
      - run: pip install -e .[test_botorch]
      - run: make doctests_botorch
      - run: pip install -e .[test_umbridge]
      - name: run umbridge doctests on Linux only
        shell: bash -l {0}
        run: |
          if [ "$RUNNER_OS" == "Linux" ]; then
            make doctests_umbridge
          else
            echo "umbridge doctests only run on Linux"
          fi
      - run: make doctests_markdown
      # -----------------------------------------------------------
      # Run unittests for Python source files
      # -----------------------------------------------------------   
      - name: Run unittests (parallel)
        run: |
          python -m pytest -n auto -q
      # -----------------------------------------------------------
      # Run unittests for Jupyter notebooks (OS-specific)
      # -----------------------------------------------------------   
      - name: Check for missing booktest files
        run: make check_booktests

      - name: Generate missing booktest files
        run: make generate_booktests

      - name: Run booktests (parallel) on macOS (43 mins) and Ubuntu (20 mins)
        if: runner.os != 'Windows'
        shell: bash -l {0}
        run: |
          make booktests_parallel_no_docker

      - name: Run booktests (sequential) on Windows
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Execute notebook integration tests in parallel
          $env:MPLBACKEND = "Agg"
          make booktests_no_docker TESTS="tb_*.py"